{"ast":null,"code":"var _jsxFileName = \"E:\\\\RailBite\\\\RailBite-main (2)\\\\src\\\\context\\\\NotificationContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { notificationAPI } from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst NotificationContext = /*#__PURE__*/createContext();\nexport const useNotification = () => {\n  _s();\n  const context = useContext(NotificationContext);\n  if (!context) {\n    throw new Error('useNotification must be used within NotificationProvider');\n  }\n  return context;\n};\n\n// Helper: get the right token based on what's available\n_s(useNotification, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst getToken = () => {\n  return localStorage.getItem('railbiteToken') || localStorage.getItem('railbite_token') || localStorage.getItem('railbite_delivery_token') || null;\n};\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s2();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const fetchNotifications = useCallback(async () => {\n    const token = getToken();\n    if (!token) {\n      setNotifications([]);\n      setUnreadCount(0);\n      return;\n    }\n    try {\n      setLoading(true);\n      const res = await notificationAPI.getMyNotifications(token);\n      if (res.data.success) {\n        const data = res.data.data || [];\n        setNotifications(data);\n        setUnreadCount(data.filter(n => !n.read).length);\n      }\n    } catch (err) {\n      console.error('Failed to fetch notifications:', err.message);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n  const fetchUnreadCount = useCallback(async () => {\n    const token = getToken();\n    if (!token) return;\n    try {\n      const res = await notificationAPI.getUnreadCount(token);\n      if (res.data.success) {\n        setUnreadCount(res.data.data.count);\n      }\n    } catch (err) {\n      console.error('Failed to fetch unread count:', err.message);\n    }\n  }, []);\n  const markAsRead = useCallback(async notificationId => {\n    const token = getToken();\n    if (!token) return;\n    try {\n      await notificationAPI.markAsRead(notificationId, token);\n      setNotifications(prev => prev.map(n => n._id === notificationId ? {\n        ...n,\n        read: true\n      } : n));\n      setUnreadCount(prev => Math.max(0, prev - 1));\n    } catch (err) {\n      console.error('Failed to mark as read:', err.message);\n    }\n  }, []);\n  const markAllAsRead = useCallback(async () => {\n    const token = getToken();\n    if (!token) return;\n    try {\n      await notificationAPI.markAllAsRead(token);\n      setNotifications(prev => prev.map(n => ({\n        ...n,\n        read: true\n      })));\n      setUnreadCount(0);\n    } catch (err) {\n      console.error('Failed to mark all as read:', err.message);\n    }\n  }, []);\n\n  // Fetch on mount and poll every 30 seconds\n  useEffect(() => {\n    fetchNotifications();\n    const interval = setInterval(fetchUnreadCount, 30000);\n    return () => clearInterval(interval);\n  }, [fetchNotifications, fetchUnreadCount]);\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: {\n      notifications,\n      unreadCount,\n      loading,\n      fetchNotifications,\n      fetchUnreadCount,\n      markAsRead,\n      markAllAsRead\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 102,\n    columnNumber: 5\n  }, this);\n};\n_s2(NotificationProvider, \"T4mQqPKqBJvRppToWC/UJn66iSQ=\");\n_c = NotificationProvider;\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","notificationAPI","jsxDEV","_jsxDEV","NotificationContext","useNotification","_s","context","Error","getToken","localStorage","getItem","NotificationProvider","children","_s2","notifications","setNotifications","unreadCount","setUnreadCount","loading","setLoading","fetchNotifications","token","res","getMyNotifications","data","success","filter","n","read","length","err","console","error","message","fetchUnreadCount","getUnreadCount","count","markAsRead","notificationId","prev","map","_id","Math","max","markAllAsRead","interval","setInterval","clearInterval","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["E:/RailBite/RailBite-main (2)/src/context/NotificationContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\r\nimport { notificationAPI } from '../services/api';\r\n\r\nconst NotificationContext = createContext();\r\n\r\nexport const useNotification = () => {\r\n  const context = useContext(NotificationContext);\r\n  if (!context) {\r\n    throw new Error('useNotification must be used within NotificationProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Helper: get the right token based on what's available\r\nconst getToken = () => {\r\n  return (\r\n    localStorage.getItem('railbiteToken') ||\r\n    localStorage.getItem('railbite_token') ||\r\n    localStorage.getItem('railbite_delivery_token') ||\r\n    null\r\n  );\r\n};\r\n\r\nexport const NotificationProvider = ({ children }) => {\r\n  const [notifications, setNotifications] = useState([]);\r\n  const [unreadCount, setUnreadCount] = useState(0);\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  const fetchNotifications = useCallback(async () => {\r\n    const token = getToken();\r\n    if (!token) {\r\n      setNotifications([]);\r\n      setUnreadCount(0);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setLoading(true);\r\n      const res = await notificationAPI.getMyNotifications(token);\r\n      if (res.data.success) {\r\n        const data = res.data.data || [];\r\n        setNotifications(data);\r\n        setUnreadCount(data.filter(n => !n.read).length);\r\n      }\r\n    } catch (err) {\r\n      console.error('Failed to fetch notifications:', err.message);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  const fetchUnreadCount = useCallback(async () => {\r\n    const token = getToken();\r\n    if (!token) return;\r\n\r\n    try {\r\n      const res = await notificationAPI.getUnreadCount(token);\r\n      if (res.data.success) {\r\n        setUnreadCount(res.data.data.count);\r\n      }\r\n    } catch (err) {\r\n      console.error('Failed to fetch unread count:', err.message);\r\n    }\r\n  }, []);\r\n\r\n  const markAsRead = useCallback(async (notificationId) => {\r\n    const token = getToken();\r\n    if (!token) return;\r\n\r\n    try {\r\n      await notificationAPI.markAsRead(notificationId, token);\r\n      setNotifications(prev =>\r\n        prev.map(n => n._id === notificationId ? { ...n, read: true } : n)\r\n      );\r\n      setUnreadCount(prev => Math.max(0, prev - 1));\r\n    } catch (err) {\r\n      console.error('Failed to mark as read:', err.message);\r\n    }\r\n  }, []);\r\n\r\n  const markAllAsRead = useCallback(async () => {\r\n    const token = getToken();\r\n    if (!token) return;\r\n\r\n    try {\r\n      await notificationAPI.markAllAsRead(token);\r\n      setNotifications(prev => prev.map(n => ({ ...n, read: true })));\r\n      setUnreadCount(0);\r\n    } catch (err) {\r\n      console.error('Failed to mark all as read:', err.message);\r\n    }\r\n  }, []);\r\n\r\n  // Fetch on mount and poll every 30 seconds\r\n  useEffect(() => {\r\n    fetchNotifications();\r\n    const interval = setInterval(fetchUnreadCount, 30000);\r\n    return () => clearInterval(interval);\r\n  }, [fetchNotifications, fetchUnreadCount]);\r\n\r\n  return (\r\n    <NotificationContext.Provider value={{\r\n      notifications,\r\n      unreadCount,\r\n      loading,\r\n      fetchNotifications,\r\n      fetchUnreadCount,\r\n      markAsRead,\r\n      markAllAsRead\r\n    }}>\r\n      {children}\r\n    </NotificationContext.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}